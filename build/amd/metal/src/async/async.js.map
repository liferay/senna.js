{"version":3,"sources":["async.js"],"names":[],"mappings":"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","file":"node_modules/metal/src/async/async.js","sourcesContent":["/*!\n * Polyfill from Google's Closure Library.\n * Copyright 2013 The Closure Library Authors. All Rights Reserved.\n */\n\n'use strict';\n\nvar async = {};\n\n\n/**\n * Throw an item without interrupting the current execution context.  For\n * example, if processing a group of items in a loop, sometimes it is useful\n * to report an error while still allowing the rest of the batch to be\n * processed.\n * @param {*} exception\n */\nasync.throwException = function(exception) {\n\t// Each throw needs to be in its own context.\n\tasync.nextTick(function() {\n\t\tthrow exception;\n\t});\n};\n\n\n/**\n * Fires the provided callback just before the current callstack unwinds, or as\n * soon as possible after the current JS execution context.\n * @param {function(this:THIS)} callback\n * @param {THIS=} opt_context Object to use as the \"this value\" when calling\n *     the provided function.\n * @template THIS\n */\nasync.run = function(callback, opt_context) {\n\tif (!async.run.workQueueScheduled_) {\n\t\t// Nothing is currently scheduled, schedule it now.\n\t\tasync.nextTick(async.run.processWorkQueue);\n\t\tasync.run.workQueueScheduled_ = true;\n\t}\n\n\tasync.run.workQueue_.push(\n\t\tnew async.run.WorkItem_(callback, opt_context));\n};\n\n\n/** @private {boolean} */\nasync.run.workQueueScheduled_ = false;\n\n\n/** @private {!Array.<!async.run.WorkItem_>} */\nasync.run.workQueue_ = [];\n\n/**\n * Run any pending async.run work items. This function is not intended\n * for general use, but for use by entry point handlers to run items ahead of\n * async.nextTick.\n */\nasync.run.processWorkQueue = function() {\n\t// NOTE: additional work queue items may be pushed while processing.\n\twhile (async.run.workQueue_.length) {\n\t\t// Don't let the work queue grow indefinitely.\n\t\tvar workItems = async.run.workQueue_;\n\t\tasync.run.workQueue_ = [];\n\t\tfor (var i = 0; i < workItems.length; i++) {\n\t\t\tvar workItem = workItems[i];\n\t\t\ttry {\n\t\t\t\tworkItem.fn.call(workItem.scope);\n\t\t\t} catch (e) {\n\t\t\t\tasync.throwException(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t// There are no more work items, reset the work queue.\n\tasync.run.workQueueScheduled_ = false;\n};\n\n\n/**\n * @constructor\n * @final\n * @struct\n * @private\n *\n * @param {function()} fn\n * @param {Object|null|undefined} scope\n */\nasync.run.WorkItem_ = function(fn, scope) {\n\t/** @const */\n\tthis.fn = fn;\n\t/** @const */\n\tthis.scope = scope;\n};\n\n\n/**\n * Fires the provided callbacks as soon as possible after the current JS\n * execution context. setTimeout(â€¦, 0) always takes at least 5ms for legacy\n * reasons.\n * @param {function(this:SCOPE)} callback Callback function to fire as soon as\n *     possible.\n * @param {SCOPE=} opt_context Object in whose scope to call the listener.\n * @template SCOPE\n */\nasync.nextTick = function(callback, opt_context) {\n\tvar cb = callback;\n\tif (opt_context) {\n\t\tcb = callback.bind(opt_context);\n\t}\n\tcb = async.nextTick.wrapCallback_(cb);\n\t// Introduced and currently only supported by IE10.\n\t// Verify if variable is defined on the current runtime (i.e., node, browser).\n\t// Can't use typeof enclosed in a function (such as core.isFunction) or an\n\t// exception will be thrown when the function is called on an environment\n\t// where the variable is undefined.\n\tif (typeof setImmediate === 'function') {\n\t\tsetImmediate(cb);\n\t\treturn;\n\t}\n\t// Look for and cache the custom fallback version of setImmediate.\n\tif (!async.nextTick.setImmediate_) {\n\t\tasync.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();\n\t}\n\tasync.nextTick.setImmediate_(cb);\n};\n\n\n/**\n * Cache for the setImmediate implementation.\n * @type {function(function())}\n * @private\n */\nasync.nextTick.setImmediate_ = null;\n\n\n/**\n * Determines the best possible implementation to run a function as soon as\n * the JS event loop is idle.\n * @return {function(function())} The \"setImmediate\" implementation.\n * @private\n */\nasync.nextTick.getSetImmediateEmulator_ = function() {\n\t// Create a private message channel and use it to postMessage empty messages\n\t// to ourselves.\n\tvar Channel;\n\n\t// Verify if variable is defined on the current runtime (i.e., node, browser).\n\t// Can't use typeof enclosed in a function (such as core.isFunction) or an\n\t// exception will be thrown when the function is called on an environment\n\t// where the variable is undefined.\n\tif (typeof MessageChannel === 'function') {\n\t\tChannel = MessageChannel;\n\t}\n\n\t// If MessageChannel is not available and we are in a browser, implement\n\t// an iframe based polyfill in browsers that have postMessage and\n\t// document.addEventListener. The latter excludes IE8 because it has a\n\t// synchronous postMessage implementation.\n\tif (typeof Channel === 'undefined' && typeof window !== 'undefined' &&\n\t\twindow.postMessage && window.addEventListener) {\n\t\t/** @constructor */\n\t\tChannel = function() {\n\t\t\t// Make an empty, invisible iframe.\n\t\t\tvar iframe = document.createElement('iframe');\n\t\t\tiframe.style.display = 'none';\n\t\t\tiframe.src = '';\n\t\t\tdocument.documentElement.appendChild(iframe);\n\t\t\tvar win = iframe.contentWindow;\n\t\t\tvar doc = win.document;\n\t\t\tdoc.open();\n\t\t\tdoc.write('');\n\t\t\tdoc.close();\n\t\t\tvar message = 'callImmediate' + Math.random();\n\t\t\tvar origin = win.location.protocol + '//' + win.location.host;\n\t\t\tvar onmessage = function(e) {\n\t\t\t\t// Validate origin and message to make sure that this message was\n\t\t\t\t// intended for us.\n\t\t\t\tif (e.origin !== origin && e.data !== message) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.port1.onmessage();\n\t\t\t}.bind(this);\n\t\t\twin.addEventListener('message', onmessage, false);\n\t\t\tthis.port1 = {};\n\t\t\tthis.port2 = {\n\t\t\t\tpostMessage: function() {\n\t\t\t\t\twin.postMessage(message, origin);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\tif (typeof Channel !== 'undefined') {\n\t\tvar channel = new Channel();\n\t\t// Use a fifo linked list to call callbacks in the right order.\n\t\tvar head = {};\n\t\tvar tail = head;\n\t\tchannel.port1.onmessage = function() {\n\t\t\thead = head.next;\n\t\t\tvar cb = head.cb;\n\t\t\thead.cb = null;\n\t\t\tcb();\n\t\t};\n\t\treturn function(cb) {\n\t\t\ttail.next = {\n\t\t\t\tcb: cb\n\t\t\t};\n\t\t\ttail = tail.next;\n\t\t\tchannel.port2.postMessage(0);\n\t\t};\n\t}\n\t// Implementation for IE6-8: Script elements fire an asynchronous\n\t// onreadystatechange event when inserted into the DOM.\n\tif (typeof document !== 'undefined' && 'onreadystatechange' in\n\t\tdocument.createElement('script')) {\n\t\treturn function(cb) {\n\t\t\tvar script = document.createElement('script');\n\t\t\tscript.onreadystatechange = function() {\n\t\t\t\t// Clean up and call the callback.\n\t\t\t\tscript.onreadystatechange = null;\n\t\t\t\tscript.parentNode.removeChild(script);\n\t\t\t\tscript = null;\n\t\t\t\tcb();\n\t\t\t\tcb = null;\n\t\t\t};\n\t\t\tdocument.documentElement.appendChild(script);\n\t\t};\n\t}\n\t// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms\n\t// or more.\n\treturn function(cb) {\n\t\tsetTimeout(cb, 0);\n\t};\n};\n\n\n/**\n * Helper function that is overrided to protect callbacks with entry point\n * monitor if the application monitors entry points.\n * @param {function()} callback Callback function to fire as soon as possible.\n * @return {function()} The wrapped callback.\n * @private\n */\nasync.nextTick.wrapCallback_ = function(opt_returnValue) {\n\treturn opt_returnValue;\n};\n\nexport default async;\n"],"sourceRoot":"/source/"}