{"version":3,"sources":["object.js"],"names":["object","target","key","source","i","arguments","length","name","opt_obj","scope","window","parts","split","reduce","part","obj","fn","mappedObj","keys","Object","obj1","obj2","keys1","keys2"],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAEMA,M;;;;;;;yBAOQC,M,EAAQ;AACpB,QAAIC,YAAJ;AAAA,QAASC,eAAT;AACA,SAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIC,UAAUC,MAA9B,EAAsCF,GAAtC,EAA2C;AAC1CD,cAASE,UAAUD,CAAV,CAAT;AACA,UAAKF,GAAL,IAAYC,MAAZ,EAAoB;AACnBF,aAAOC,GAAP,IAAcC,OAAOD,GAAP,CAAd;AACA;AACD;AACD,WAAOD,MAAP;AACA;;;mCASsBM,I,EAAMC,O,EAAS;AACrC,QAAMC,QAAQD,WAAWE,MAAzB;AACA,QAAMC,QAAQJ,KAAKK,KAAL,CAAW,GAAX,CAAd;AACA,WAAOD,MAAME,MAAN,CAAa,UAACC,IAAD,EAAOZ,GAAP;AAAA,YAAeY,KAAKZ,GAAL,CAAf;AAAA,KAAb,EAAuCO,KAAvC,CAAP;AACA;;;uBASUM,G,EAAKC,E,EAAI;AACnB,QAAMC,YAAY,EAAlB;AACA,QAAMC,OAAOC,OAAOD,IAAP,CAAYH,GAAZ,CAAb;AACA,SAAK,IAAIX,IAAI,CAAb,EAAgBA,IAAIc,KAAKZ,MAAzB,EAAiCF,GAAjC,EAAsC;AACrCa,eAAUC,KAAKd,CAAL,CAAV,IAAqBY,GAAGE,KAAKd,CAAL,CAAH,EAAYW,IAAIG,KAAKd,CAAL,CAAJ,CAAZ,CAArB;AACA;AACD,WAAOa,SAAP;AACA;;;gCAOmBG,I,EAAMC,I,EAAM;AAC/B,QAAID,SAASC,IAAb,EAAmB;AAClB,YAAO,IAAP;AACA;;AAED,QAAMC,QAAQH,OAAOD,IAAP,CAAYE,IAAZ,CAAd;AACA,QAAMG,QAAQJ,OAAOD,IAAP,CAAYG,IAAZ,CAAd;AACA,QAAIC,MAAMhB,MAAN,KAAiBiB,MAAMjB,MAA3B,EAAmC;AAClC,YAAO,KAAP;AACA;;AAED,SAAK,IAAIF,IAAI,CAAb,EAAgBA,IAAIkB,MAAMhB,MAA1B,EAAkCF,GAAlC,EAAuC;AACtC,SAAIgB,KAAKE,MAAMlB,CAAN,CAAL,MAAmBiB,KAAKC,MAAMlB,CAAN,CAAL,CAAvB,EAAuC;AACtC,aAAO,KAAP;AACA;AACD;AACD,WAAO,IAAP;AACA;;;;;;mBAGaJ,M","file":"node_modules/metal/src/object/object.js","sourcesContent":["'use strict';\n\nclass object {\n\t/**\n\t * Copies all the members of a source object to a target object.\n\t * @param {Object} target Target object.\n\t * @param {...Object} var_args The objects from which values will be copied.\n\t * @return {Object} Returns the target object reference.\n\t */\n\tstatic mixin(target) {\n\t\tlet key, source;\n\t\tfor (let i = 1; i < arguments.length; i++) {\n\t\t\tsource = arguments[i];\n\t\t\tfor (key in source) {\n\t\t\t\ttarget[key] = source[key];\n\t\t\t}\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Returns an object based on its fully qualified external name.\n\t * @param {string} name The fully qualified name.\n\t * @param {object=} opt_obj The object within which to look; default is\n\t *     <code>window</code>.\n\t * @return {?} The value (object or primitive) or, if not found, undefined.\n\t */\n\tstatic getObjectByName(name, opt_obj) {\n\t\tconst scope = opt_obj || window;\n\t\tconst parts = name.split('.');\n\t\treturn parts.reduce((part, key) => part[key], scope);\n\t}\n\n\t/**\n\t * Returns a new object with the same keys as the given one, but with\n\t * their values set to the return values of the specified function.\n\t * @param {!Object} obj\n\t * @param {!function(string, *)} fn\n\t * @return {!Object}\n\t */\n\tstatic map(obj, fn) {\n\t\tconst mappedObj = {};\n\t\tconst keys = Object.keys(obj);\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tmappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);\n\t\t}\n\t\treturn mappedObj;\n\t}\n\n\t/**\n\t * Checks if the two given objects are equal. This is done via a shallow\n\t * check, including only the keys directly contained by the 2 objects.\n\t * @return {boolean}\n\t */\n\tstatic shallowEqual(obj1, obj2) {\n\t\tif (obj1 === obj2) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst keys1 = Object.keys(obj1);\n\t\tconst keys2 = Object.keys(obj2);\n\t\tif (keys1.length !== keys2.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = 0; i < keys1.length; i++) {\n\t\t\tif (obj1[keys1[i]] !== obj2[keys1[i]]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nexport default object;\n"],"sourceRoot":"/source/"}