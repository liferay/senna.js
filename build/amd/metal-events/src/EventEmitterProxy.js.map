{"version":3,"sources":["EventEmitterProxy.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBAqIe","file":"node_modules/metal-events/src/EventEmitterProxy.js","sourcesContent":["'use strict';\n\nimport { Disposable, object } from 'metal';\n\n/**\n * EventEmitterProxy utility. It's responsible for linking two EventEmitter\n * instances together, emitting events from the first emitter through the\n * second one. That means that listening to a supported event on the target\n * emitter will mean listening to it on the origin emitter as well.\n * @param {EventEmitter} originEmitter Events originated on this emitter\n *   will be fired for the target emitter's listeners as well.\n * @param {EventEmitter} targetEmitter Event listeners attached to this emitter\n *   will also be triggered when the event is fired by the origin emitter.\n * @param {Object} opt_blacklist Optional blacklist of events that should not be\n *   proxied.\n * @constructor\n * @extends {Disposable}\n */\nclass EventEmitterProxy extends Disposable {\n\tconstructor(originEmitter, targetEmitter, opt_blacklist, opt_whitelist) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Map of events that should not be proxied.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.blacklist_ = opt_blacklist || {};\n\n\t\t/**\n\t\t * The origin emitter. This emitter's events will be proxied through the\n\t\t * target emitter.\n\t\t * @type {EventEmitter}\n\t\t * @protected\n\t\t */\n\t\tthis.originEmitter_ = originEmitter;\n\n\t\t/**\n\t\t * Holds a map of events from the origin emitter that are already being proxied.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.proxiedEvents_ = {};\n\n\t\t/**\n\t\t * The target emitter. This emitter will emit all events that come from\n\t\t * the origin emitter.\n\t\t * @type {EventEmitter}\n\t\t * @protected\n\t\t */\n\t\tthis.targetEmitter_ = targetEmitter;\n\n\t\t/**\n\t\t * Map of events that should be proxied. If whitelist is set blacklist is ignored.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.whitelist_ = opt_whitelist;\n\n\t\tthis.startProxy_();\n\t}\n\n\t/**\n\t * Adds the proxy listener for the given event.\n\t * @param {string} event.\n\t * @protected\n\t */\n\taddListener_(event) {\n\t\tthis.originEmitter_.on(event, this.proxiedEvents_[event]);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tobject.map(this.proxiedEvents_, this.removeListener_.bind(this));\n\t\tthis.proxiedEvents_ = null;\n\t\tthis.originEmitter_ = null;\n\t\tthis.targetEmitter_ = null;\n\t}\n\n\t/**\n\t * Proxies the given event from the origin to the target emitter.\n\t * @param {string} event\n\t */\n\tproxyEvent_(event) {\n\t\tif (!this.shouldProxyEvent_(event)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar self = this;\n\t\tthis.proxiedEvents_[event] = function() {\n\t\t\tvar args = [event].concat(Array.prototype.slice.call(arguments, 0));\n\t\t\tself.targetEmitter_.emit.apply(self.targetEmitter_, args);\n\t\t};\n\n\t\tthis.addListener_(event);\n\t}\n\n\t/**\n\t * Removes the proxy listener for the given event.\n\t * @param {string} event\n\t * @protected\n\t */\n\tremoveListener_(event) {\n\t\tthis.originEmitter_.removeListener(event, this.proxiedEvents_[event]);\n\t}\n\n\t/**\n\t * Checks if the given event should be proxied.\n\t * @param {string} event\n\t * @return {boolean}\n\t * @protected\n\t */\n\tshouldProxyEvent_(event) {\n\t\tif (this.whitelist_ && !this.whitelist_[event]) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.blacklist_[event]) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !this.proxiedEvents_[event];\n\t}\n\n\t/**\n\t * Starts proxying all events from the origin to the target emitter.\n\t * @protected\n\t */\n\tstartProxy_() {\n\t\tthis.targetEmitter_.on('newListener', this.proxyEvent_.bind(this));\n\t}\n}\n\nexport default EventEmitterProxy;\n"],"sourceRoot":"/source/"}