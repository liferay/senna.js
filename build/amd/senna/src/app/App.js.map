{"version":3,"sources":["App.js"],"names":["NavigationStrategy","IMMEDIATE","SCHEDULE_LAST","App","activeScreen","activePath","allowPreventNavigate","basePath","browserPathBeforeNavigate","getCurrentBrowserPathWithoutHash","captureScrollPositionFromScrollEvent","defaultTitle","document","title","formSelector","ignoreQueryStringFromRoutePath","linkSelector","loadingCssClass","nativeScrollRestorationSupported","window","history","navigationStrategy","isNavigationPending","pendingNavigate","popstateScrollLeft","popstateScrollTop","redirectPath","routes","scheduledNavigationQueue","screens","skipLoadPopstate","surfaces","updateScrollPosition","appEventHandlers_","add","debounce","onScroll_","bind","onLoad_","onPopstate_","on","onStartNavigate_","onBeforeNavigate_","onBeforeNavigateDefault_","onBeforeUnloadDefault_","setLinkSelector","setFormSelector","maybeOverloadBeforeUnload_","Array","isArray","forEach","route","path","handler","push","surface","getId","url","uri","isWebUri","getUrlPath","isLinkSameOrigin_","getHost","console","log","isSameBasePath_","getHash","isCurrentBrowserPath","findRoute","Object","keys","clearCache","removeScreen","screen","getHandler","isImplementedBy","prototype","clearScreensCache","formEventHandler_","removeListener","linkEventHandler_","removeAllListeners","navigate","getCurrentBrowserPath","opt_replaceHistory","Promise","reject","Error","stopPendingNavigate_","nextScreen","createScreenInstance","finalize","length","scheduledNavigation","shift","maybeNavigate_","href","maybePreventDeactivate_","then","maybePreventActivate_","load","deactivate","prepareNavigateHistory_","prepareNavigateSurfaces_","extractParams","evaluateStyles","flip","evaluateScripts","maybeUpdateScrollPositionState_","syncScrollPositionSyncThenAsync_","finalizeNavigate_","catch","reason","handleNavigateError_","getRoutePath","activate","isCacheable","capturedFormElement","capturedFormButtonElement","i","matchesPath","getIgnoreQueryStringFromRoutePath","getUrlPathWithoutHashAndSearch","substr","getUrlPathWithoutHash","error","stack","emit","host","hostUri","locationHostUri","location","getPort","getHostname","indexOf","state","winner","switchScrollPositionRace","removeEventListener","scrollTo","scrollLeft","scrollTop","nextTick","addEventListener","nativeScrollRestoration_","scrollRestoration","event","mixin","isScheduledNavigation","canNavigate","isNavigationScheduled","maybeScheduleNavigation_","preventDefault","navigateFailed","err","onbeforeunload","_onbeforeunload","defaultPrevented","_overloaded","resolve","beforeActivate","prevent","beforeDeactivate","hash","anchorElement","getElementById","substring","getNodeOffset","offsetLeft","offsetTop","saveHistoryCurrentPageScrollPosition_","opt_event","isHtml5HistorySupported","replaceHistory","form","func","altKey","ctrlKey","metaKey","shiftKey","button","delegateTarget","method","buttonSelector","activeElement","querySelector","action","setTimeout","maybeRepositionScrollToHashedAnchor","reloadPage","senna","lockHistoryScrollPosition_","once","referrer","setReferrer","setHostname","hostname","setPort","port","toString","pageYOffset","pageXOffset","maybeDisableNativeScrollRestoration","documentElement","endNavigatePayload","maybeRestoreNativeScrollRestoration","doNavigate_","getTitle","getDefaultTitle","beforeUpdateHistoryPath","historyState","maybeRestoreRedirectPathHash_","updateHistory_","beforeUpdateHistoryState","params","id","surfaceContent","getSurfaceContent","addContent","reload","remove","surfaceId","dispose","replaceState","removePathTrailingSlash","onDocSubmitDelegate_","onDocClickDelegate_","sync","pushState","titleNode","innerHTML"],"mappings":"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","file":"src/app/App.js","sourcesContent":["'use strict';\n\nimport { addClasses, delegate, match, on, removeClasses } from 'metal-dom';\nimport { array, async, isDefAndNotNull, isString, object } from 'metal';\nimport { EventEmitter, EventHandler } from 'metal-events';\nimport globals from '../globals/globals';\nimport Route from '../route/Route';\nimport Screen from '../screen/Screen';\nimport Surface from '../surface/Surface';\nimport Uri from 'metal-uri';\nimport utils from '../utils/utils';\n\nconst NavigationStrategy = {\n\tIMMEDIATE: 'immediate',\n\tSCHEDULE_LAST: 'scheduleLast'\n};\n\nclass App extends EventEmitter {\n\n\t/**\n\t * App class that handle routes and screens lifecycle.\n\t * @constructor\n\t * @extends {EventEmitter}\n\t */\n\tconstructor() {\n\t\tsuper();\n\n\t\t/**\n\t\t * Holds the active screen.\n\t\t * @type {?Screen}\n\t\t * @protected\n\t\t */\n\t\tthis.activeScreen = null;\n\n\t\t/**\n\t\t * Holds the active path containing the query parameters.\n\t\t * @type {?string}\n\t\t * @protected\n\t\t */\n\t\tthis.activePath = null;\n\n\t\t/**\n\t\t * Allows prevent navigate from dom prevented event.\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t * @protected\n\t\t */\n\t\tthis.allowPreventNavigate = true;\n\n\t\t/**\n\t\t * Holds link base path.\n\t\t * @type {!string}\n\t\t * @default ''\n\t\t * @protected\n\t\t */\n\t\tthis.basePath = '';\n\n\t\t/**\n\t\t * Holds the value of the browser path before a navigation is performed.\n\t\t * @type {!string}\n\t\t * @default the current browser path.\n\t\t * @protected\n\t\t */\n\t\tthis.browserPathBeforeNavigate = utils.getCurrentBrowserPathWithoutHash();\n\n\t\t/**\n\t\t * Captures scroll position from scroll event.\n\t\t * @type {!boolean}\n\t\t * @default true\n\t\t * @protected\n\t\t */\n\t\tthis.captureScrollPositionFromScrollEvent = true;\n\n\t\t/**\n\t\t * Holds the default page title.\n\t\t * @type {string}\n\t\t * @default null\n\t\t * @protected\n\t\t */\n\t\tthis.defaultTitle = globals.document.title;\n\n\t\t/**\n\t\t * Holds the form selector to define forms that are routed.\n\t\t * @type {!string}\n\t\t * @default form[enctype=\"multipart/form-data\"]:not([data-senna-off])\n\t\t * @protected\n\t\t */\n\t\tthis.formSelector = 'form[enctype=\"multipart/form-data\"]:not([data-senna-off])';\n\n\t\t/**\n\t\t * When enabled, the route matching ignores query string from the path.\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis.ignoreQueryStringFromRoutePath = false;\n\n\t\t/**\n\t\t * Holds the link selector to define links that are routed.\n\t\t * @type {!string}\n\t\t * @default a:not([data-senna-off])\n\t\t * @protected\n\t\t */\n\t\tthis.linkSelector = 'a:not([data-senna-off]):not([target=\"_blank\"])';\n\n\t\t/**\n\t\t * Holds the loading css class.\n\t\t * @type {!string}\n\t\t * @default senna-loading\n\t\t * @protected\n\t\t */\n\t\tthis.loadingCssClass = 'senna-loading';\n\n\t\t/**\n\t\t * Using the History API to manage your URLs is awesome and, as it happens,\n\t\t * a crucial feature of good web apps. One of its downsides, however, is\n\t\t * that scroll positions are stored and then, more importantly, restored\n\t\t * whenever you traverse the history. This often means unsightly jumps as\n\t\t * the scroll position changes automatically, and especially so if your app\n\t\t * does transitions, or changes the contents of the page in any way.\n\t\t * Ultimately this leads to an horrible user experience. The good news is,\n\t\t * however, that thereâ€™s a potential fix: history.scrollRestoration.\n\t\t * https://developers.google.com/web/updates/2015/09/history-api-scroll-restoration\n\t\t * @type {boolean}\n\t\t * @protected\n\t\t */\n\t\tthis.nativeScrollRestorationSupported = ('scrollRestoration' in globals.window.history);\n\n\t\t/**\n\t\t * When set to NavigationStrategy.SCHEDULE_LAST means that the current navigation\n\t\t * cannot be Cancelled to start another and will be queued in\n\t\t * scheduledNavigationQueue. When NavigationStrategy.IMMEDIATE means that all\n\t\t * navigation will be cancelled to start another.\n\t\t * @type {!string}\n\t\t * @default immediate\n\t\t * @protected\n\t\t */\n\t\tthis.navigationStrategy = NavigationStrategy.IMMEDIATE;\n\n\t\t/**\n\t\t * When set to true there is a pendingNavigate that has not yet been\n\t\t * resolved or rejected.\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis.isNavigationPending = false;\n\n\t\t/**\n\t\t * Holds a deferred with the current navigation.\n\t\t * @type {?Promise}\n\t\t * @default null\n\t\t * @protected\n\t\t */\n\t\tthis.pendingNavigate = null;\n\n\t\t/**\n\t\t * Holds the window horizontal scroll position when the navigation using\n\t\t * back or forward happens to be restored after the surfaces are updated.\n\t\t * @type {!Number}\n\t\t * @default 0\n\t\t * @protected\n\t\t */\n\t\tthis.popstateScrollLeft = 0;\n\n\t\t/**\n\t\t * Holds the window vertical scroll position when the navigation using\n\t\t * back or forward happens to be restored after the surfaces are updated.\n\t\t * @type {!Number}\n\t\t * @default 0\n\t\t * @protected\n\t\t */\n\t\tthis.popstateScrollTop = 0;\n\n\t\t/**\n\t\t * Holds the redirect path containing the query parameters.\n\t\t * @type {?string}\n\t\t * @protected\n\t\t */\n\t\tthis.redirectPath = null;\n\n\t\t/**\n\t\t * Holds the screen routes configuration.\n\t\t * @type {?Array}\n\t\t * @default []\n\t\t * @protected\n\t\t */\n\t\tthis.routes = [];\n\n\t\t/**\n\t\t * Holds a queue that stores every DOM event that can initiate a navigation.\n\t\t * @type {!Event}\n\t\t * @default []\n\t\t * @protected\n\t\t */\n\t\tthis.scheduledNavigationQueue = [];\n\n\t\t/**\n\t\t * Maps the screen instances by the url containing the parameters.\n\t\t * @type {?Object}\n\t\t * @default {}\n\t\t * @protected\n\t\t */\n\t\tthis.screens = {};\n\n\t\t/**\n\t\t * When set to true the first erroneous popstate fired on page load will be\n\t\t * ignored, only if <code>globals.window.history.state</code> is also\n\t\t * <code>null</code>.\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @protected\n\t\t */\n\t\tthis.skipLoadPopstate = false;\n\n\t\t/**\n\t\t * Maps that index the surfaces instances by the surface id.\n\t\t * @type {?Object}\n\t\t * @default {}\n\t\t * @protected\n\t\t */\n\t\tthis.surfaces = {};\n\n\t\t/**\n\t\t * When set to true, moves the scroll position after popstate, or to the\n\t\t * top of the viewport for new navigation. If false, the browser will\n\t\t * take care of scroll restoration.\n\t\t * @type {!boolean}\n\t\t * @default true\n\t\t * @protected\n\t\t */\n\t\tthis.updateScrollPosition = true;\n\n\t\tthis.appEventHandlers_ = new EventHandler();\n\n\t\tthis.appEventHandlers_.add(\n\t\t\ton(globals.window, 'scroll', utils.debounce(this.onScroll_.bind(this), 100)),\n\t\t\ton(globals.window, 'load', this.onLoad_.bind(this)),\n\t\t\ton(globals.window, 'popstate', this.onPopstate_.bind(this))\n\t\t);\n\n\t\tthis.on('startNavigate', this.onStartNavigate_);\n\t\tthis.on('beforeNavigate', this.onBeforeNavigate_);\n\t\tthis.on('beforeNavigate', this.onBeforeNavigateDefault_, true);\n\t\tthis.on('beforeUnload', this.onBeforeUnloadDefault_);\n\n\t\tthis.setLinkSelector(this.linkSelector);\n\t\tthis.setFormSelector(this.formSelector);\n\n\t\tthis.maybeOverloadBeforeUnload_();\n\t}\n\n\t/**\n\t * Adds one or more screens to the application.\n\t *\n\t * Example:\n\t *\n\t * <code>\n\t *   app.addRoutes({ path: '/foo', handler: FooScreen });\n\t *   or\n\t *   app.addRoutes([{ path: '/foo', handler: function(route) { return new FooScreen(); } }]);\n\t * </code>\n\t *\n\t * @param {Object} or {Array} routes Single object or an array of object.\n\t *     Each object should contain <code>path</code> and <code>screen</code>.\n\t *     The <code>path</code> should be a string or a regex that maps the\n\t *     navigation route to a screen class definition (not an instance), e.g:\n\t *         <code>{ path: \"/home:param1\", handler: MyScreen }</code>\n\t *         <code>{ path: /foo.+/, handler: MyScreen }</code>\n\t * @chainable\n\t */\n\taddRoutes(routes) {\n\t\tif (!Array.isArray(routes)) {\n\t\t\troutes = [routes];\n\t\t}\n\t\troutes.forEach((route) => {\n\t\t\tif (!(route instanceof Route)) {\n\t\t\t\troute = new Route(route.path, route.handler);\n\t\t\t}\n\t\t\tthis.routes.push(route);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds one or more surfaces to the application.\n\t * @param {Surface|String|Array.<Surface|String>} surfaces\n\t *     Surface element id or surface instance. You can also pass an Array\n\t *     whichcontains surface instances or id. In case of ID, these should be\n\t *     the id of surface element.\n\t * @chainable\n\t */\n\taddSurfaces(surfaces) {\n\t\tif (!Array.isArray(surfaces)) {\n\t\t\tsurfaces = [surfaces];\n\t\t}\n\t\tsurfaces.forEach((surface) => {\n\t\t\tif (isString(surface)) {\n\t\t\t\tsurface = new Surface(surface);\n\t\t\t}\n\t\t\tthis.surfaces[surface.getId()] = surface;\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns if can navigate to path.\n\t * @param {!string} url\n\t * @return {boolean}\n\t */\n\tcanNavigate(url) {\n\t\tconst uri = utils.isWebUri(url);\n\n\t\tif (!uri) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst path = utils.getUrlPath(url);\n\n\t\tif (!this.isLinkSameOrigin_(uri.getHost())) {\n\t\t\tconsole.log('Offsite link clicked');\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.isSameBasePath_(path)) {\n\t\t\tconsole.log('Link clicked outside app\\'s base path');\n\t\t\treturn false;\n\t\t}\n\t\t// Prevents navigation if it's a hash change on the same url.\n\t\tif (uri.getHash() && utils.isCurrentBrowserPath(path)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this.findRoute(path)) {\n\t\t\tconsole.log('No route for ' + path);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Clear screens cache.\n\t * @chainable\n\t */\n\tclearScreensCache() {\n\t\tObject.keys(this.screens).forEach((path) => {\n\t\t\tif (path === this.activePath) {\n\t\t\t\tthis.activeScreen.clearCache();\n\t\t\t} else if (!(this.isNavigationPending && this.pendingNavigate.path === path)) {\n\t\t\t\tthis.removeScreen(path);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves or create a screen instance to a path.\n\t * @param {!string} path Path containing the querystring part.\n\t * @return {Screen}\n\t */\n\tcreateScreenInstance(path, route) {\n\t\tif (!this.pendingNavigate && path === this.activePath) {\n\t\t\tconsole.log('Already at destination, refresh navigation');\n\t\t\treturn this.activeScreen;\n\t\t}\n\t\t/* jshint newcap: false */\n\t\tvar screen = this.screens[path];\n\t\tif (!screen) {\n\t\t\tvar handler = route.getHandler();\n\t\t\tif (handler === Screen || Screen.isImplementedBy(handler.prototype)) {\n\t\t\t\tscreen = new handler();\n\t\t\t} else {\n\t\t\t\tscreen = handler(route) || new Screen();\n\t\t\t}\n\t\t\tconsole.log('Create screen for [' + path + '] [' + screen + ']');\n\t\t}\n\t\treturn screen;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tif (this.activeScreen) {\n\t\t\tthis.removeScreen(this.activePath);\n\t\t}\n\t\tthis.clearScreensCache();\n\t\tthis.formEventHandler_.removeListener();\n\t\tthis.linkEventHandler_.removeListener();\n\t\tthis.appEventHandlers_.removeAllListeners();\n\t\tsuper.disposeInternal();\n\t}\n\n\t/**\n\t * Dispatches to the first route handler that matches the current path, if\n\t * any.\n\t * @return {Promise} Returns a pending request promise.\n\t */\n\tdispatch() {\n\t\treturn this.navigate(utils.getCurrentBrowserPath(), true);\n\t}\n\n\t/**\n\t * Starts navigation to a path.\n\t * @param {!string} path Path containing the querystring part.\n\t * @param {boolean=} opt_replaceHistory Replaces browser history.\n\t * @return {Promise} Returns a pending request promise.\n\t */\n\tdoNavigate_(path, opt_replaceHistory) {\n\t\tvar route = this.findRoute(path);\n\t\tif (!route) {\n\t\t\tthis.pendingNavigate = Promise.reject(new Error('No route for ' + path));\n\t\t\treturn this.pendingNavigate;\n\t\t}\n\n\t\tconsole.log('Navigate to [' + path + ']');\n\n\t\tthis.stopPendingNavigate_();\n\t\tthis.isNavigationPending = true;\n\n\t\tvar nextScreen = this.createScreenInstance(path, route);\n\n\t\tconst finalize = () => {\n\t\t\tthis.navigationStrategy = NavigationStrategy.IMMEDIATE;\n\n\t\t\tif (this.scheduledNavigationQueue.length) {\n\t\t\t\tconst scheduledNavigation = this.scheduledNavigationQueue.shift();\n\t\t\t\tthis.maybeNavigate_(scheduledNavigation.href, scheduledNavigation);\n\t\t\t}\n\t\t};\n\n\t\treturn this.maybePreventDeactivate_()\n\t\t\t.then(() => this.maybePreventActivate_(nextScreen))\n\t\t\t.then(() => nextScreen.load(path))\n\t\t\t.then(() => {\n\t\t\t\t// At this point we cannot stop navigation and all received\n\t\t\t\t// navigate candidates will be queued at scheduledNavigationQueue.\n\t\t\t\tthis.navigationStrategy = NavigationStrategy.SCHEDULE_LAST;\n\n\t\t\t\tif (this.activeScreen) {\n\t\t\t\t\tthis.activeScreen.deactivate();\n\t\t\t\t}\n\t\t\t\tthis.prepareNavigateHistory_(path, nextScreen, opt_replaceHistory);\n\t\t\t\tthis.prepareNavigateSurfaces_(\n\t\t\t\t\tnextScreen,\n\t\t\t\t\tthis.surfaces,\n\t\t\t\t\tthis.extractParams(route, path)\n\t\t\t\t);\n\t\t\t})\n\t\t\t.then(() => nextScreen.evaluateStyles(this.surfaces))\n\t\t\t.then(() => nextScreen.flip(this.surfaces))\n\t\t\t.then(() => nextScreen.evaluateScripts(this.surfaces))\n\t\t\t.then(() => this.maybeUpdateScrollPositionState_())\n\t\t\t.then(() => this.syncScrollPositionSyncThenAsync_())\n\t\t\t.then(() => this.finalizeNavigate_(path, nextScreen))\n\t\t\t.then(() => this.maybeOverloadBeforeUnload_())\n\t\t\t.then(() => {\n\t\t\t\tfinalize();\n\t\t\t})\n\t\t\t.catch((reason) => {\n\t\t\t\tthis.isNavigationPending = false;\n\t\t\t\tthis.handleNavigateError_(path, nextScreen, reason);\n\t\t\t\tfinalize();\n\t\t\t\tthrow reason;\n\t\t\t});\n\t}\n\n\t/**\n\t * Extracts params according to the given path and route.\n\t * @param {!Route} route\n\t * @param {string} path\n\t * @param {!Object}\n\t */\n\textractParams(route, path) {\n\t\treturn route.extractParams(this.getRoutePath(path));\n\t}\n\n\t/**\n\t * Finalizes a screen navigation.\n\t * @param {!string} path Path containing the querystring part.\n\t * @param {!Screen} nextScreen\n\t * @protected\n\t */\n\tfinalizeNavigate_(path, nextScreen) {\n\t\tnextScreen.activate();\n\n\t\tif (this.activeScreen && !this.activeScreen.isCacheable()) {\n\t\t\tif (this.activeScreen !== nextScreen) {\n\t\t\t\tthis.removeScreen(this.activePath);\n\t\t\t}\n\t\t}\n\n\t\tthis.activePath = path;\n\t\tthis.activeScreen = nextScreen;\n\t\tthis.browserPathBeforeNavigate = utils.getCurrentBrowserPathWithoutHash();\n\t\tthis.screens[path] = nextScreen;\n\t\tthis.isNavigationPending = false;\n\t\tthis.pendingNavigate = null;\n\t\tglobals.capturedFormElement = null;\n\t\tglobals.capturedFormButtonElement = null;\n\t\tconsole.log('Navigation done');\n\t}\n\n\t/**\n\t * Finds a route for the test path. Returns true if matches has a route,\n\t * otherwise returns null.\n\t * @param {!string} path Path containing the querystring part.\n\t * @return {?Object} Route handler if match any or <code>null</code> if the\n\t *     path is the same as the current url and the path contains a fragment.\n\t */\n\tfindRoute(path) {\n\t\tpath = this.getRoutePath(path);\n\t\tfor (var i = 0; i < this.routes.length; i++) {\n\t\t\tvar route = this.routes[i];\n\t\t\tif (route.matchesPath(path)) {\n\t\t\t\treturn route;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Gets allow prevent navigate.\n\t * @return {boolean}\n\t */\n\tgetAllowPreventNavigate() {\n\t\treturn this.allowPreventNavigate;\n\t}\n\n\t/**\n\t * Gets link base path.\n\t * @return {!string}\n\t */\n\tgetBasePath() {\n\t\treturn this.basePath;\n\t}\n\n\t/**\n\t * Gets the default page title.\n\t * @return {string} defaultTitle\n\t */\n\tgetDefaultTitle() {\n\t\treturn this.defaultTitle;\n\t}\n\n\t/**\n\t * Gets the form selector.\n\t * @return {!string}\n\t */\n\tgetFormSelector() {\n\t\treturn this.formSelector;\n\t}\n\n\t/**\n\t * Check if route matching is ignoring query string from the route path.\n\t * @return {boolean}\n\t */\n\tgetIgnoreQueryStringFromRoutePath() {\n\t\treturn this.ignoreQueryStringFromRoutePath;\n\t}\n\n\t/**\n\t * Gets the link selector.\n\t * @return {!string}\n\t */\n\tgetLinkSelector() {\n\t\treturn this.linkSelector;\n\t}\n\n\t/**\n\t * Gets the loading css class.\n\t * @return {!string}\n\t */\n\tgetLoadingCssClass() {\n\t\treturn this.loadingCssClass;\n\t}\n\n\t/**\n\t * Returns the given path formatted to be matched by a route. This will,\n\t * for example, remove the base path from it, but make sure it will end\n\t * with a '/'.\n\t * @param {string} path\n\t * @return {string}\n\t */\n\tgetRoutePath(path) {\n\t\tif (this.getIgnoreQueryStringFromRoutePath()) {\n\t\t\tpath = utils.getUrlPathWithoutHashAndSearch(path);\n\t\t\treturn utils.getUrlPathWithoutHashAndSearch(path.substr(this.basePath.length));\n\t\t}\n\n\t\tpath = utils.getUrlPathWithoutHash(path);\n\t\treturn utils.getUrlPathWithoutHash(path.substr(this.basePath.length));\n\t}\n\n\t/**\n\t * Gets the update scroll position value.\n\t * @return {boolean}\n\t */\n\tgetUpdateScrollPosition() {\n\t\treturn this.updateScrollPosition;\n\t}\n\n\t/**\n\t * Handle navigation error.\n\t * @param {!string} path Path containing the querystring part.\n\t * @param {!Screen} nextScreen\n\t * @param {!Error} error\n\t * @protected\n\t */\n\thandleNavigateError_(path, nextScreen, error) {\n\t\tconsole.log('Navigation error for [' + nextScreen + '] (' + error.stack + ')');\n\t\tthis.emit('navigationError', {\n\t\t\terror,\n\t\t\tnextScreen,\n\t\t\tpath\n\t\t});\n\t\tif (!utils.isCurrentBrowserPath(path)) {\n\t\t\tif (this.isNavigationPending && this.pendingNavigate) {\n\t\t\t\tthis.pendingNavigate\n\t\t\t\t\t.then(() => this.removeScreen(path))\n\t\t\t\t\t.catch(error => {\n\t\t\t\t\t\tthis.removeScreen(path);\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.removeScreen(path);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if app has routes.\n\t * @return {boolean}\n\t */\n\thasRoutes() {\n\t\treturn this.routes.length > 0;\n\t}\n\n\t/**\n\t * Tests if host is an offsite link.\n\t * @param {!string} host Link host to compare with\n\t *     <code>globals.window.location.host</code>.\n\t * @return {boolean}\n\t * @protected\n\t */\n\tisLinkSameOrigin_(host) {\n\t\tconst hostUri = new Uri(host);\n\t\tconst locationHostUri = new Uri(globals.window.location.host);\n\n\t\treturn hostUri.getPort() === locationHostUri.getPort() && hostUri.getHostname() === locationHostUri.getHostname();\n\t}\n\n\t/**\n\t * Tests if link element has the same app's base path.\n\t * @param {!string} path Link path containing the querystring part.\n\t * @return {boolean}\n\t * @protected\n\t */\n\tisSameBasePath_(path) {\n\t\treturn path.indexOf(this.basePath) === 0;\n\t}\n\n\t/**\n\t * Lock the document scroll in order to avoid the browser native back and\n\t * forward navigation to change the scroll position. In the end of\n\t * navigation lifecycle scroll is repositioned.\n\t * @protected\n\t */\n\tlockHistoryScrollPosition_() {\n\t\tvar state = globals.window.history.state;\n\t\tif (!state) {\n\t\t\treturn;\n\t\t}\n\t\t// Browsers are inconsistent when re-positioning the scroll history on\n\t\t// popstate. At some browsers, history scroll happens before popstate, then\n\t\t// lock the scroll on the last known position as soon as possible after the\n\t\t// current JS execution context and capture the current value. Some others,\n\t\t// history scroll happens after popstate, in this case, we bind an once\n\t\t// scroll event to lock the las known position. Lastly, the previous two\n\t\t// behaviors can happen even on the same browser, hence the race will decide\n\t\t// the winner.\n\t\tvar winner = false;\n\t\tvar switchScrollPositionRace = function() {\n\t\t\tglobals.document.removeEventListener('scroll', switchScrollPositionRace, false);\n\t\t\tif (!winner) {\n\t\t\t\tglobals.window.scrollTo(state.scrollLeft, state.scrollTop);\n\t\t\t\twinner = true;\n\t\t\t}\n\t\t};\n\t\tasync.nextTick(switchScrollPositionRace);\n\t\tglobals.document.addEventListener('scroll', switchScrollPositionRace, false);\n\t}\n\n\t/**\n\t * If supported by the browser, disables native scroll restoration and\n\t * stores current value.\n\t */\n\tmaybeDisableNativeScrollRestoration() {\n\t\tif (this.nativeScrollRestorationSupported) {\n\t\t\tthis.nativeScrollRestoration_ = globals.window.history.scrollRestoration;\n\t\t\tglobals.window.history.scrollRestoration = 'manual';\n\t\t}\n\t}\n\n\t/**\n\t * This method is used to evaluate if is possible to queue received\n\t *  dom event to scheduleNavigationQueue and enqueue it.\n\t * @param {string} href Information about the link's href.\n\t * @param {Event} event Dom event that initiated the navigation.\n\t */\n\tmaybeScheduleNavigation_(href, event) {\n\t\tif (this.isNavigationPending && this.navigationStrategy === NavigationStrategy.SCHEDULE_LAST) {\n\t\t\tthis.scheduledNavigationQueue = [object.mixin({\n\t\t\t\thref,\n\t\t\t\tisScheduledNavigation: true\n\t\t\t}, event)];\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Maybe navigate to a path.\n\t * @param {string} href Information about the link's href.\n\t * @param {Event} event Dom event that initiated the navigation.\n\t */\n\tmaybeNavigate_(href, event) {\n\t\tif (!this.canNavigate(href)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst isNavigationScheduled = this.maybeScheduleNavigation_(href, event);\n\n\t\tif (isNavigationScheduled) {\n\t\t\tevent.preventDefault();\n\t\t\treturn;\n\t\t}\n\n\t\tvar navigateFailed = false;\n\t\ttry {\n\t\t\tthis.navigate(utils.getUrlPath(href), false, event);\n\t\t} catch (err) {\n\t\t\t// Do not prevent link navigation in case some synchronous error occurs\n\t\t\tnavigateFailed = true;\n\t\t}\n\n\t\tif (!navigateFailed && !event.isScheduledNavigation) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether the onbeforeunload global event handler is overloaded\n\t * by client code. If so, it replaces with a function that halts the normal\n\t * event flow in relation with the client onbeforeunload function.\n\t * This can be in most part used to prematurely terminate navigation to other pages\n\t * according to the given constrait(s).\n\t * @protected\n\t */\n\tmaybeOverloadBeforeUnload_() {\n\t\tif ('function' === typeof window.onbeforeunload) {\n\t\t\twindow._onbeforeunload = window.onbeforeunload;\n\n\t\t\twindow.onbeforeunload = event => {\n\t\t\t\tthis.emit('beforeUnload', event);\n\t\t\t\tif (event && event.defaultPrevented) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// mark the updated handler due unwanted recursion\n\t\t\twindow.onbeforeunload._overloaded = true;\n\t\t}\n\t}\n\n\t/**\n\t * Cancels navigation if nextScreen's beforeActivate lifecycle method\n\t * resolves to true.\n\t * @param {!Screen} nextScreen\n\t * @return {!Promise}\n\t */\n\tmaybePreventActivate_(nextScreen) {\n\t\treturn Promise.resolve()\n\t\t\t.then(() => {\n\t\t\t\treturn nextScreen.beforeActivate();\n\t\t\t})\n\t\t\t.then(prevent => {\n\t\t\t\tif (prevent) {\n\t\t\t\t\tthis.pendingNavigate = Promise.reject('Cancelled by next screen');\n\t\t\t\t\treturn this.pendingNavigate;\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\t/**\n\t * Cancels navigation if activeScreen's beforeDeactivate lifecycle\n\t * method resolves to true.\n\t * @return {!Promise}\n\t */\n\tmaybePreventDeactivate_() {\n\t\treturn Promise.resolve()\n\t\t\t.then(() => {\n\t\t\t\tif (this.activeScreen) {\n\t\t\t\t\treturn this.activeScreen.beforeDeactivate();\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then(prevent => {\n\t\t\t\tif (prevent) {\n\t\t\t\t\tthis.pendingNavigate = Promise.reject(new Error('Cancelled by active screen'));\n\t\t\t\t\treturn this.pendingNavigate;\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\t/**\n\t * Maybe reposition scroll to hashed anchor.\n\t */\n\tmaybeRepositionScrollToHashedAnchor() {\n\t\tconst hash = globals.window.location.hash;\n\t\tif (hash) {\n\t\t\tlet anchorElement = globals.document.getElementById(hash.substring(1));\n\t\t\tif (anchorElement) {\n\t\t\t\tconst {offsetLeft, offsetTop} = utils.getNodeOffset(anchorElement);\n\t\t\t\tglobals.window.scrollTo(offsetLeft, offsetTop);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * If supported by the browser, restores native scroll restoration to the\n\t * value captured by `maybeDisableNativeScrollRestoration`.\n\t */\n\tmaybeRestoreNativeScrollRestoration() {\n\t\tif (this.nativeScrollRestorationSupported && this.nativeScrollRestoration_) {\n\t\t\tglobals.window.history.scrollRestoration = this.nativeScrollRestoration_;\n\t\t}\n\t}\n\n\t/**\n\t * Maybe restore redirected path hash in case both the current path and\n\t * the given path are the same.\n\t * @param {!string} path Path before navigation.\n\t * @param {!string} redirectPath Path after navigation.\n\t * @param {!string} hash Hash to be added to the path.\n\t * @return {!string} Returns the path with the hash restored.\n\t */\n\tmaybeRestoreRedirectPathHash_(path, redirectPath, hash) {\n\t\tif (redirectPath === utils.getUrlPathWithoutHash(path)) {\n\t\t\treturn redirectPath + hash;\n\t\t}\n\t\treturn redirectPath;\n\t}\n\n\t/**\n\t * Maybe update scroll position in history state to anchor on path.\n\t * @param {!string} path Path containing anchor\n\t */\n\tmaybeUpdateScrollPositionState_() {\n\t\tvar hash = globals.window.location.hash;\n\t\tvar anchorElement = globals.document.getElementById(hash.substring(1));\n\t\tif (anchorElement) {\n\t\t\tconst {offsetLeft, offsetTop} = utils.getNodeOffset(anchorElement);\n\t\t\tthis.saveHistoryCurrentPageScrollPosition_(offsetTop, offsetLeft);\n\t\t}\n\t}\n\n\t/**\n\t * Navigates to the specified path if there is a route handler that matches.\n\t * @param {!string} path Path to navigate containing the base path.\n\t * @param {boolean=} opt_replaceHistory Replaces browser history.\n\t * @param {Event=} event Optional event object that triggered the navigation.\n\t * @return {Promise} Returns a pending request promise.\n\t */\n\tnavigate(path, opt_replaceHistory, opt_event) {\n\t\tif (!utils.isHtml5HistorySupported()) {\n\t\t\tthrow new Error('HTML5 History is not supported. Senna will not intercept navigation.');\n\t\t}\n\n\t\tif (opt_event) {\n\t\t\tglobals.capturedFormElement = opt_event.capturedFormElement;\n\t\t\tglobals.capturedFormButtonElement = opt_event.capturedFormButtonElement;\n\t\t}\n\n\t\t// When reloading the same path do replaceState instead of pushState to\n\t\t// avoid polluting history with states with the same path.\n\t\tif (path === this.activePath) {\n\t\t\topt_replaceHistory = true;\n\t\t}\n\n\t\tthis.emit('beforeNavigate', {\n\t\t\tevent: opt_event,\n\t\t\tpath: path,\n\t\t\treplaceHistory: !!opt_replaceHistory\n\t\t});\n\n\t\treturn this.pendingNavigate;\n\t}\n\n\t/**\n\t * Befores navigation to a path.\n\t * @param {!Event} event Event facade containing <code>path</code> and\n\t *     <code>replaceHistory</code>.\n\t * @protected\n\t */\n\tonBeforeNavigate_(event) {\n\t\tif (globals.capturedFormElement) {\n\t\t\tevent.form = globals.capturedFormElement;\n\t\t}\n\t}\n\n\t/**\n\t * Befores navigation to a path. Runs after external listeners.\n\t * @param {!Event} event Event facade containing <code>path</code> and\n\t *     <code>replaceHistory</code>.\n\t * @protected\n\t */\n\tonBeforeNavigateDefault_(event) {\n\t\tif (this.pendingNavigate) {\n\t\t\tif (this.pendingNavigate.path === event.path || this.navigationStrategy === NavigationStrategy.SCHEDULE_LAST) {\n\t\t\t\tconsole.log('Waiting...');\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.emit('beforeUnload', event);\n\n\t\tthis.emit('startNavigate', {\n\t\t\tform: event.form,\n\t\t\tpath: event.path,\n\t\t\treplaceHistory: event.replaceHistory\n\t\t});\n\t}\n\n\t/**\n\t * Custom event handler that executes the original listener that has been\n\t * added by the client code and terminates the navigation accordingly.\n\t * @param {!Event} event original Event facade.\n\t * @protected\n\t */\n\tonBeforeUnloadDefault_(event) {\n\t\tvar func = window._onbeforeunload;\n\t\tif (func && !func._overloaded && func()) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n\n\t/**\n\t * Intercepts document clicks and test link elements in order to decide\n\t * whether Surface app can navigate.\n\t * @param {!Event} event Event facade\n\t * @protected\n\t */\n\tonDocClickDelegate_(event) {\n\t\tif (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey || event.button) {\n\t\t\tconsole.log('Navigate aborted, invalid mouse button or modifier key pressed.');\n\t\t\treturn;\n\t\t}\n\t\tthis.maybeNavigate_(event.delegateTarget.href, event);\n\t}\n\n\t/**\n\t * Intercepts document form submits and test action path in order to decide\n\t * whether Surface app can navigate.\n\t * @param {!Event} event Event facade\n\t * @protected\n\t */\n\tonDocSubmitDelegate_(event) {\n\t\tvar form = event.delegateTarget;\n\t\tif (form.method === 'get') {\n\t\t\tconsole.log('GET method not supported');\n\t\t\treturn;\n\t\t}\n\t\tevent.capturedFormElement = form;\n\t\tconst buttonSelector = 'button:not([type]),button[type=submit],input[type=submit]';\n\t\tif (match(globals.document.activeElement, buttonSelector)) {\n\t\t\tevent.capturedFormButtonElement = globals.document.activeElement;\n\t\t} else {\n\t\t\tevent.capturedFormButtonElement = form.querySelector(buttonSelector);\n\t\t}\n\t\tthis.maybeNavigate_(form.action, event);\n\t}\n\n\t/**\n\t * Listens to the window's load event in order to avoid issues with some browsers\n\t * that trigger popstate calls on the first load. For more information see\n\t * http://stackoverflow.com/questions/6421769/popstate-on-pages-load-in-chrome.\n\t * @protected\n\t */\n\tonLoad_() {\n\t\tthis.skipLoadPopstate = true;\n\t\tsetTimeout(() => {\n\t\t\t// The timeout ensures that popstate events will be unblocked right\n\t\t\t// after the load event occured, but not in the same event-loop cycle.\n\t\t\tthis.skipLoadPopstate = false;\n\t\t}, 0);\n\t\t// Try to reposition scroll to the hashed anchor when page loads.\n\t\tthis.maybeRepositionScrollToHashedAnchor();\n\t}\n\n\t/**\n\t * Handles browser history changes and fires app's navigation if the state\n\t * belows to us. If we detect a popstate and the state is <code>null</code>,\n\t * assume it is navigating to an external page or to a page we don't have\n\t * route, then <code>globals.window.location.reload()</code> is invoked in order to\n\t * reload the content to the current url.\n\t * @param {!Event} event Event facade\n\t * @protected\n\t */\n\tonPopstate_(event) {\n\t\tif (this.skipLoadPopstate) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Do not navigate if the popstate was triggered by a hash change.\n\t\tif (utils.isCurrentBrowserPath(this.browserPathBeforeNavigate)) {\n\t\t\tthis.maybeRepositionScrollToHashedAnchor();\n\t\t\treturn;\n\t\t}\n\n\t\tvar state = event.state;\n\n\t\tif (!state) {\n\t\t\tif (globals.window.location.hash) {\n\t\t\t\t// If senna is on an redirect path and a hash popstate happens\n\t\t\t\t// to a different url, reload the browser. This behavior doesn't\n\t\t\t\t// require senna to route hashed links and is closer to native\n\t\t\t\t// browser behavior.\n\t\t\t\tif (this.redirectPath && !utils.isCurrentBrowserPath(this.redirectPath)) {\n\t\t\t\t\tthis.reloadPage();\n\t\t\t\t}\n\t\t\t\t// Always try to reposition scroll to the hashed anchor when\n\t\t\t\t// hash popstate happens.\n\t\t\t\tthis.maybeRepositionScrollToHashedAnchor();\n\t\t\t} else {\n\t\t\t\tthis.reloadPage();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (state.senna) {\n\t\t\tconsole.log('History navigation to [' + state.path + ']');\n\t\t\tthis.popstateScrollTop = state.scrollTop;\n\t\t\tthis.popstateScrollLeft = state.scrollLeft;\n\t\t\tif (!this.nativeScrollRestorationSupported) {\n\t\t\t\tthis.lockHistoryScrollPosition_();\n\t\t\t}\n\t\t\tthis.once('endNavigate', () => {\n\t\t\t\tif (state.referrer) {\n\t\t\t\t\tutils.setReferrer(state.referrer);\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst uri = new Uri(state.path);\n\t\t\turi.setHostname(globals.window.location.hostname);\n\t\t\turi.setPort(globals.window.location.port);\n\t\t\tconst isNavigationScheduled = this.maybeScheduleNavigation_(uri.toString(), {});\n\t\t\tif (isNavigationScheduled) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.navigate(state.path, true);\n\t\t}\n\t}\n\n\t/**\n\t * Listens document scroll changes in order to capture the possible lock\n\t * scroll position for history scrolling.\n\t * @protected\n\t */\n\tonScroll_() {\n\t\tif (this.captureScrollPositionFromScrollEvent) {\n\t\t\tthis.saveHistoryCurrentPageScrollPosition_(globals.window.pageYOffset, globals.window.pageXOffset);\n\t\t}\n\t}\n\n\t/**\n\t * Starts navigation to a path.\n\t * @param {!Event} event Event facade containing <code>path</code> and\n\t *     <code>replaceHistory</code>.\n\t * @protected\n\t */\n\tonStartNavigate_(event) {\n\t\tthis.maybeDisableNativeScrollRestoration();\n\t\tthis.captureScrollPositionFromScrollEvent = false;\n\t\taddClasses(globals.document.documentElement, this.loadingCssClass);\n\n\t\tvar endNavigatePayload = {\n\t\t\tform: event.form,\n\t\t\tpath: event.path\n\t\t};\n\n\t\tconst finalize = (endNavigatePayload) => {\n\t\t\tif (!this.pendingNavigate && !this.scheduledNavigationQueue.length) {\n\t\t\t\tremoveClasses(globals.document.documentElement, this.loadingCssClass);\n\t\t\t\tthis.maybeRestoreNativeScrollRestoration();\n\t\t\t\tthis.captureScrollPositionFromScrollEvent = true;\n\t\t\t}\n\t\t\tthis.emit('endNavigate', endNavigatePayload);\n\t\t};\n\n\t\tthis.pendingNavigate = this.doNavigate_(event.path, event.replaceHistory)\n\t\t\t.then(() => {\n\t\t\t\tfinalize(endNavigatePayload);\n\t\t\t})\n\t\t\t.catch((reason) => {\n\t\t\t\tfinalize(endNavigatePayload);\n\t\t\t\tendNavigatePayload.error = reason;\n\t\t\t\tthrow reason;\n\t\t\t});\n\n\t\tthis.pendingNavigate.path = event.path;\n\t}\n\n\t/**\n\t * Prefetches the specified path if there is a route handler that matches.\n\t * @param {!string} path Path to navigate containing the base path.\n\t * @return {Promise} Returns a pending request promise.\n\t */\n\tprefetch(path) {\n\t\tvar route = this.findRoute(path);\n\t\tif (!route) {\n\t\t\treturn Promise.reject(new Error('No route for ' + path));\n\t\t}\n\n\t\tconsole.log('Prefetching [' + path + ']');\n\n\t\tvar nextScreen = this.createScreenInstance(path, route);\n\n\t\treturn nextScreen.load(path)\n\t\t\t.then(() => this.screens[path] = nextScreen)\n\t\t\t.catch((reason) => {\n\t\t\t\tthis.handleNavigateError_(path, nextScreen, reason);\n\t\t\t\tthrow reason;\n\t\t\t});\n\t}\n\n\t/**\n\t * Prepares screen flip. Updates history state and surfaces content.\n\t * @param {!string} path Path containing the querystring part.\n\t * @param {!Screen} nextScreen\n\t * @param {boolean=} opt_replaceHistory Replaces browser history.\n\t */\n\tprepareNavigateHistory_(path, nextScreen, opt_replaceHistory) {\n\t\tlet title = nextScreen.getTitle();\n\t\tif (!isString(title)) {\n\t\t\ttitle = this.getDefaultTitle();\n\t\t}\n\t\tlet redirectPath = nextScreen.beforeUpdateHistoryPath(path);\n\t\tconst historyState = {\n\t\t\tform: isDefAndNotNull(globals.capturedFormElement),\n\t\t\tpath,\n\t\t\tredirectPath,\n\t\t\tscrollLeft: 0,\n\t\t\tscrollTop: 0,\n\t\t\tsenna: true\n\t\t};\n\t\tif (opt_replaceHistory) {\n\t\t\thistoryState.scrollTop = this.popstateScrollTop;\n\t\t\thistoryState.scrollLeft = this.popstateScrollLeft;\n\t\t}\n\t\tconst hash = new Uri(path).getHash();\n\t\tredirectPath = this.maybeRestoreRedirectPathHash_(path, redirectPath, hash);\n\t\tthis.updateHistory_(title, redirectPath, nextScreen.beforeUpdateHistoryState(historyState), opt_replaceHistory);\n\t\tthis.redirectPath = redirectPath;\n\t}\n\n\t/**\n\t * Prepares screen flip. Updates history state and surfaces content.\n\t * @param {!Screen} nextScreen\n\t * @param {!Object} surfaces Map of surfaces to flip keyed by surface id.\n\t * @param {!Object} params Params extracted from the current path.\n\t */\n\tprepareNavigateSurfaces_(nextScreen, surfaces, params) {\n\t\tObject.keys(surfaces).forEach((id) => {\n\t\t\tvar surfaceContent = nextScreen.getSurfaceContent(id, params);\n\t\t\tsurfaces[id].addContent(nextScreen.getId(), surfaceContent);\n\t\t\tconsole.log('Screen [' + nextScreen.getId() + '] add content to surface ' +\n\t\t\t\t'[' + surfaces[id] + '] [' + (isDefAndNotNull(surfaceContent) ? '...' : 'empty') + ']');\n\t\t});\n\t}\n\n\t/**\n\t * Reloads the page by performing `window.location.reload()`.\n\t */\n\treloadPage() {\n\t\tglobals.window.location.reload();\n\t}\n\n\t/**\n\t * Removes route instance from app routes.\n\t * @param {Route} route\n\t * @return {boolean} True if an element was removed.\n\t */\n\tremoveRoute(route) {\n\t\treturn array.remove(this.routes, route);\n\t}\n\n\t/**\n\t * Removes a screen.\n\t * @param {!string} path Path containing the querystring part.\n\t */\n\tremoveScreen(path) {\n\t\tvar screen = this.screens[path];\n\t\tif (screen) {\n\t\t\tObject.keys(this.surfaces).forEach((surfaceId) => this.surfaces[surfaceId].remove(screen.getId()));\n\t\t\tscreen.dispose();\n\t\t\tdelete this.screens[path];\n\t\t}\n\t}\n\n\t/**\n\t * Saves given scroll position into history state.\n\t * @param {!number} scrollTop Number containing the top scroll position to be saved.\n\t * @param {!number} scrollLeft Number containing the left scroll position to be saved.\n\t */\n\tsaveHistoryCurrentPageScrollPosition_(scrollTop, scrollLeft) {\n\t\tvar state = globals.window.history.state;\n\t\tif (state && state.senna) {\n\t\t\t[state.scrollTop, state.scrollLeft] = [scrollTop, scrollLeft];\n\t\t\tglobals.window.history.replaceState(state, null, null);\n\t\t}\n\t}\n\n\t/**\n\t * Sets allow prevent navigate.\n\t * @param {boolean} allowPreventNavigate\n\t */\n\tsetAllowPreventNavigate(allowPreventNavigate) {\n\t\tthis.allowPreventNavigate = allowPreventNavigate;\n\t}\n\n\t/**\n\t * Sets link base path.\n\t * @param {!string} path\n\t */\n\tsetBasePath(basePath) {\n\t\tthis.basePath = utils.removePathTrailingSlash(basePath);\n\t}\n\n\t/**\n\t * Sets the default page title.\n\t * @param {string} defaultTitle\n\t */\n\tsetDefaultTitle(defaultTitle) {\n\t\tthis.defaultTitle = defaultTitle;\n\t}\n\n\t/**\n\t * Sets the form selector.\n\t * @param {!string} formSelector\n\t */\n\tsetFormSelector(formSelector) {\n\t\tthis.formSelector = formSelector;\n\t\tif (this.formEventHandler_) {\n\t\t\tthis.formEventHandler_.removeListener();\n\t\t}\n\t\tthis.formEventHandler_ = delegate(document, 'submit', this.formSelector, this.onDocSubmitDelegate_.bind(this), this.allowPreventNavigate);\n\t}\n\n\t/**\n\t * Sets if route matching should ignore query string from the route path.\n\t * @param {boolean} ignoreQueryStringFromRoutePath\n\t */\n\tsetIgnoreQueryStringFromRoutePath(ignoreQueryStringFromRoutePath) {\n\t\tthis.ignoreQueryStringFromRoutePath = ignoreQueryStringFromRoutePath;\n\t}\n\n\t/**\n\t * Sets the link selector.\n\t * @param {!string} linkSelector\n\t */\n\tsetLinkSelector(linkSelector) {\n\t\tthis.linkSelector = linkSelector;\n\t\tif (this.linkEventHandler_) {\n\t\t\tthis.linkEventHandler_.removeListener();\n\t\t}\n\t\tthis.linkEventHandler_ = delegate(document, 'click', this.linkSelector, this.onDocClickDelegate_.bind(this), this.allowPreventNavigate);\n\t}\n\n\t/**\n\t * Sets the loading css class.\n\t * @param {!string} loadingCssClass\n\t */\n\tsetLoadingCssClass(loadingCssClass) {\n\t\tthis.loadingCssClass = loadingCssClass;\n\t}\n\n\t/**\n\t * Sets the update scroll position value.\n\t * @param {boolean} updateScrollPosition\n\t */\n\tsetUpdateScrollPosition(updateScrollPosition) {\n\t\tthis.updateScrollPosition = updateScrollPosition;\n\t}\n\n\t/**\n\t * Resets pending navigate.\n\t * @protected\n\t */\n\tstopPendingNavigate_() {\n\t\tthis.pendingNavigate = null;\n\t}\n\n\t/**\n\t * Sync document scroll position twice, the first one synchronous and then\n\t * one inside <code>async.nextTick</code>. Relevant to browsers that fires\n\t * scroll restoration asynchronously after popstate.\n\t * @protected\n\t * @return {?Promise=}\n\t */\n\tsyncScrollPositionSyncThenAsync_() {\n\t\tvar state = globals.window.history.state;\n\t\tif (!state) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar scrollTop = state.scrollTop;\n\t\tvar scrollLeft = state.scrollLeft;\n\n\t\tvar sync = () => {\n\t\t\tif (this.updateScrollPosition) {\n\t\t\t\tglobals.window.scrollTo(scrollLeft, scrollTop);\n\t\t\t}\n\t\t};\n\n\t\treturn new Promise(resolve => {\n\t\t\tsync();\n\t\t\tsetTimeout(() => {\n\t\t\t\tsync();\n\t\t\t\tresolve();\n\t\t\t}, 0);\n\t\t});\n\t}\n\n\t/**\n\t * Updates or replace browser history.\n\t * @param {?string} title Document title.\n\t * @param {!string} path Path containing the querystring part.\n\t * @param {!object} state\n\t * @param {boolean=} opt_replaceHistory Replaces browser history.\n\t * @protected\n\t */\n\tupdateHistory_(title, path, state, opt_replaceHistory) {\n\t\tconst referrer = globals.window.location.href;\n\n\t\tif (state) {\n\t\t\tstate.referrer = referrer;\n\t\t}\n\n\t\tif (opt_replaceHistory) {\n\t\t\tglobals.window.history.replaceState(state, title, path);\n\t\t} else {\n\t\t\tglobals.window.history.pushState(state, title, path);\n\t\t}\n\n\t\tutils.setReferrer(referrer);\n\n\t\tlet titleNode = globals.document.querySelector('title');\n\t\tif (titleNode) {\n\t\t\ttitleNode.innerHTML = title;\n\t\t} else {\n\t\t\tglobals.document.title = title;\n\t\t}\n\t}\n\n}\n\nexport default App;\n"],"sourceRoot":"/source/"}